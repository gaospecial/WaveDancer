<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘å¯è§†åŒ–å™¨ - Audio Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            padding: 10px;
        }

        .container {
            text-align: center;
            z-index: 10;
            max-width: 100%;
        }

        h1 {
            color: white;
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        #canvas {
            border-radius: 15px;
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            width: 95vw;
            max-width: 1400px;
            height: 70vh;
            max-height: 800px;
        }

        .controls {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        button {
            padding: 10px 20px;
            font-size: 0.85rem;
            font-weight: bold;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        #startBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 25px;
        }

        #startBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        #startBtn:active {
            transform: translateY(0);
        }

        #startBtn.active {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
        }

        .mode-btn {
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 0.8rem;
        }

        .mode-btn:hover {
            background: white;
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .info {
            margin-top: 0.5rem;
            color: white;
            font-size: 0.75rem;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            h1 {
                font-size: 1.3rem;
            }
            
            button {
                padding: 8px 15px;
                font-size: 0.75rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸµ éŸ³é¢‘å¯è§†åŒ–å™¨</h1>
        <canvas id="canvas"></canvas>
        <div class="controls">
            <button id="startBtn">ğŸ¤ å¯åŠ¨éº¦å…‹é£</button>
            <button class="mode-btn active" data-mode="bars">é¢‘è°±æ¡</button>
            <button class="mode-btn" data-mode="circle">åœ†å½¢æ³¢</button>
            <button class="mode-btn" data-mode="wave">æ³¢å½¢</button>
            <button class="mode-btn" data-mode="particles">ç²’å­</button>
            <button class="mode-btn" data-mode="spiral">èºæ—‹</button>
            <button class="mode-btn" data-mode="dna">DNA</button>
            <button class="mode-btn" data-mode="starburst">æ˜Ÿçˆ†</button>
            <button class="mode-btn" data-mode="rings">é¢‘è°±ç¯</button>
            <button class="mode-btn" data-mode="waveform3d">3Dæ³¢å½¢</button>
            <button class="mode-btn" data-mode="galaxy">æ˜Ÿç³»</button>
            <button class="mode-btn" data-mode="fireworks">çƒŸèŠ±</button>
            <button class="mode-btn" data-mode="matrix">çŸ©é˜µ</button>
        </div>
        <div class="info">
            <p>ç‚¹å‡»"å¯åŠ¨éº¦å…‹é£"å¼€å§‹ | æ”¯æŒ12ç§å¯è§†åŒ–æ¨¡å¼</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const modeBtns = document.querySelectorAll('.mode-btn');

        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let bufferLength;
        let isActive = false;
        let visualMode = 'bars';
        let particles = [];
        let rotation = 0;

        // è®¾ç½®canvaså°ºå¯¸ä»¥åŒ¹é…æ˜¾ç¤ºå°ºå¯¸
        function resizeCanvas() {
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            
            // é‡æ–°ç»˜åˆ¶èƒŒæ™¯
            if (!isActive) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
        }

        // åˆå§‹åŒ–canvaså°ºå¯¸
        resizeCanvas();

        // ç›‘å¬çª—å£å¤§å°å˜åŒ–
        window.addEventListener('resize', resizeCanvas);

        // åˆå§‹åŒ–éŸ³é¢‘ä¸Šä¸‹æ–‡ - æé«˜ç²¾ç»†åº¦
        async function initAudio() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                microphone = audioContext.createMediaStreamSource(stream);
                
                // æé«˜FFTå¤§å°ä»¥è·å¾—æ›´ç²¾ç»†çš„é¢‘ç‡åˆ†è¾¨ç‡
                analyser.fftSize = 4096;
                analyser.smoothingTimeConstant = 0.8;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                microphone.connect(analyser);
                
                isActive = true;
                startBtn.textContent = 'ğŸ”´ åœæ­¢';
                startBtn.classList.add('active');
                
                draw();
            } catch (err) {
                alert('æ— æ³•è®¿é—®éº¦å…‹é£: ' + err.message);
                console.error('éº¦å…‹é£è®¿é—®é”™è¯¯:', err);
            }
        }

        // åœæ­¢éŸ³é¢‘
        function stopAudio() {
            if (microphone) {
                microphone.disconnect();
            }
            if (audioContext) {
                audioContext.close();
            }
            isActive = false;
            startBtn.textContent = 'ğŸ¤ å¯åŠ¨éº¦å…‹é£';
            startBtn.classList.remove('active');
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // ç»˜åˆ¶å‡½æ•°
        function draw() {
            if (!isActive) return;
            
            requestAnimationFrame(draw);
            
            analyser.getByteFrequencyData(dataArray);
            rotation += 0.005;
            
            switch(visualMode) {
                case 'bars':
                    drawBars();
                    break;
                case 'circle':
                    drawCircle();
                    break;
                case 'wave':
                    drawWave();
                    break;
                case 'particles':
                    drawParticles();
                    break;
                case 'spiral':
                    drawSpiral();
                    break;
                case 'dna':
                    drawDNA();
                    break;
                case 'starburst':
                    drawStarburst();
                    break;
                case 'rings':
                    drawRings();
                    break;
                case 'waveform3d':
                    drawWaveform3D();
                    break;
                case 'galaxy':
                    drawGalaxy();
                    break;
                case 'fireworks':
                    drawFireworks();
                    break;
                case 'matrix':
                    drawMatrix();
                    break;
            }
        }

        // é¢‘è°±æ¡æ¨¡å¼ - æ›´ç²¾ç»†
        function drawBars() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const bars = 128; // æ˜¾ç¤ºæ›´å¤šé¢‘è°±æ¡
            const barWidth = canvas.width / bars;
            
            for (let i = 0; i < bars; i++) {
                const index = Math.floor(i * bufferLength / bars);
                const barHeight = (dataArray[index] / 255) * canvas.height * 0.85;
                
                const hue = (i / bars) * 360;
                const gradient = ctx.createLinearGradient(0, canvas.height, 0, canvas.height - barHeight);
                gradient.addColorStop(0, `hsl(${hue}, 100%, 50%)`);
                gradient.addColorStop(0.5, `hsl(${hue + 30}, 100%, 60%)`);
                gradient.addColorStop(1, `hsl(${hue + 60}, 100%, 70%)`);
                
                ctx.fillStyle = gradient;
                ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 1, barHeight);
                
                // æ·»åŠ é•œåƒæ•ˆæœ
                ctx.globalAlpha = 0.3;
                ctx.fillRect(i * barWidth, 0, barWidth - 1, barHeight * 0.3);
                ctx.globalAlpha = 1;
            }
        }

        // åœ†å½¢æ³¢æ¨¡å¼ - æ›´ç²¾ç»†
        function drawCircle() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const baseRadius = 80;
            const samples = 256; // å¢åŠ é‡‡æ ·ç‚¹
            
            // ç»˜åˆ¶å¤šå±‚åœ†å½¢
            for (let layer = 0; layer < 3; layer++) {
                ctx.beginPath();
                
                for (let i = 0; i < samples; i++) {
                    const index = Math.floor(i * bufferLength / samples);
                    const angle = (i / samples) * Math.PI * 2;
                    const amplitude = dataArray[index] / 255;
                    const r = baseRadius + amplitude * 120 + layer * 30;
                    
                    const x = centerX + Math.cos(angle) * r;
                    const y = centerY + Math.sin(angle) * r;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                
                const hue = (Date.now() / 20 + layer * 40) % 360;
                ctx.strokeStyle = `hsla(${hue}, 100%, ${60 - layer * 10}%, ${0.8 - layer * 0.2})`;
                ctx.lineWidth = 2 + layer;
                ctx.stroke();
                
                if (layer === 0) {
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, baseRadius + 120);
                    gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.2)`);
                    gradient.addColorStop(1, `hsla(${hue + 60}, 100%, 50%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                }
            }
        }

        // æ³¢å½¢æ¨¡å¼ - æ›´ç²¾ç»†ï¼Œåˆ†åˆ«æ˜¾ç¤ºé«˜ä¸­ä½éŸ³
        function drawWave() {
            analyser.getByteFrequencyData(dataArray);
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const samples = 200;
            const sliceWidth = canvas.width / samples;
            
            // å®šä¹‰é¢‘ç‡èŒƒå›´
            const lowFreqEnd = Math.floor(bufferLength * 0.1);      // ä½éŸ³: 0-10%
            const midFreqEnd = Math.floor(bufferLength * 0.4);      // ä¸­éŸ³: 10-40%
            const highFreqEnd = Math.floor(bufferLength * 0.8);     // é«˜éŸ³: 40-80%
            
            // ä½éŸ³æ³¢å½¢ (åº•éƒ¨)
            ctx.beginPath();
            for (let i = 0; i < samples; i++) {
                const index = Math.floor(i * lowFreqEnd / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * sliceWidth;
                const y = canvas.height * 0.75 + Math.sin(i * 0.05) * amplitude * 60;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = 'hsla(0, 100%, 50%, 0.9)';  // çº¢è‰² - ä½éŸ³
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // æ·»åŠ ä½éŸ³æ ‡ç­¾
            ctx.fillStyle = 'hsla(0, 100%, 50%, 0.7)';
            ctx.font = 'bold 14px sans-serif';
            ctx.fillText('ä½éŸ³ (Bass)', 10, canvas.height * 0.75 - 40);
            
            // ä¸­éŸ³æ³¢å½¢ (ä¸­éƒ¨)
            ctx.beginPath();
            for (let i = 0; i < samples; i++) {
                const index = lowFreqEnd + Math.floor(i * (midFreqEnd - lowFreqEnd) / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * sliceWidth;
                const y = canvas.height * 0.5 + Math.sin(i * 0.08) * amplitude * 70;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = 'hsla(120, 100%, 50%, 0.9)';  // ç»¿è‰² - ä¸­éŸ³
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // æ·»åŠ ä¸­éŸ³æ ‡ç­¾
            ctx.fillStyle = 'hsla(120, 100%, 50%, 0.7)';
            ctx.fillText('ä¸­éŸ³ (Mid)', 10, canvas.height * 0.5 - 40);
            
            // é«˜éŸ³æ³¢å½¢ (é¡¶éƒ¨)
            ctx.beginPath();
            for (let i = 0; i < samples; i++) {
                const index = midFreqEnd + Math.floor(i * (highFreqEnd - midFreqEnd) / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * sliceWidth;
                const y = canvas.height * 0.25 + Math.sin(i * 0.12) * amplitude * 50;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = 'hsla(240, 100%, 60%, 0.9)';  // è“è‰² - é«˜éŸ³
            ctx.lineWidth = 3;
            ctx.stroke();
            
            // æ·»åŠ é«˜éŸ³æ ‡ç­¾
            ctx.fillStyle = 'hsla(240, 100%, 60%, 0.7)';
            ctx.fillText('é«˜éŸ³ (Treble)', 10, canvas.height * 0.25 - 40);
            
            // æ·»åŠ é¢å¤–çš„è£…é¥°æ³¢å½¢å±‚
            const hue = (Date.now() / 20) % 360;
            
            // ä½éŸ³è£…é¥°å±‚
            ctx.beginPath();
            for (let i = 0; i < samples; i++) {
                const index = Math.floor(i * lowFreqEnd / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * sliceWidth;
                const y = canvas.height * 0.75 + Math.sin(i * 0.05 + 1) * amplitude * 40;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = 'hsla(0, 100%, 50%, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // ä¸­éŸ³è£…é¥°å±‚
            ctx.beginPath();
            for (let i = 0; i < samples; i++) {
                const index = lowFreqEnd + Math.floor(i * (midFreqEnd - lowFreqEnd) / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * sliceWidth;
                const y = canvas.height * 0.5 + Math.sin(i * 0.08 + 1) * amplitude * 50;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = 'hsla(120, 100%, 50%, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // é«˜éŸ³è£…é¥°å±‚
            ctx.beginPath();
            for (let i = 0; i < samples; i++) {
                const index = midFreqEnd + Math.floor(i * (highFreqEnd - midFreqEnd) / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * sliceWidth;
                const y = canvas.height * 0.25 + Math.sin(i * 0.12 + 1) * amplitude * 35;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            ctx.strokeStyle = 'hsla(240, 100%, 60%, 0.4)';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // ç²’å­æ¨¡å¼ - æ›´ç²¾ç»†
        function drawParticles() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const average = dataArray.reduce((a, b) => a + b) / bufferLength;
            
            // æ ¹æ®éŸ³é¢‘å¼ºåº¦åˆ›å»ºç²’å­
            if (average > 30 && particles.length < 300) {
                const count = Math.floor(average / 20);
                for (let i = 0; i < count; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 5 + 2;
                    particles.push({
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        size: Math.random() * 4 + 1,
                        hue: Math.random() * 360,
                        life: 1,
                        alpha: Math.random() * 0.5 + 0.5
                    });
                }
            }
            
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.008;
                p.size *= 0.99;
                
                if (p.life > 0) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                    gradient.addColorStop(0, `hsla(${p.hue}, 100%, 60%, ${p.life * p.alpha})`);
                    gradient.addColorStop(1, `hsla(${p.hue}, 100%, 50%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    return true;
                }
                return false;
            });
        }

        // èºæ—‹æ¨¡å¼
        function drawSpiral() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const samples = 200;
            
            ctx.beginPath();
            
            for (let i = 0; i < samples; i++) {
                const index = Math.floor(i * bufferLength / samples);
                const amplitude = dataArray[index] / 255;
                const angle = (i / samples) * Math.PI * 6 + rotation;
                const radius = (i / samples) * 180 + amplitude * 50;
                
                const x = centerX + Math.cos(angle) * radius;
                const y = centerY + Math.sin(angle) * radius;
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
                
                // ç»˜åˆ¶ç‚¹
                const hue = (i / samples) * 360;
                ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.fillRect(x - 2, y - 2, 4, 4);
            }
            
            const hue = (Date.now() / 20) % 360;
            ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.5)`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // DNAåŒèºæ—‹æ¨¡å¼
        function drawDNA() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const samples = 150;
            const spacing = canvas.width / samples;
            
            for (let i = 0; i < samples; i++) {
                const index = Math.floor(i * bufferLength / samples);
                const amplitude = dataArray[index] / 255;
                const x = i * spacing;
                const angle = (i / samples) * Math.PI * 4 + rotation;
                
                // ç¬¬ä¸€æ¡èºæ—‹
                const y1 = canvas.height / 2 + Math.sin(angle) * (60 + amplitude * 40);
                const hue1 = (i / samples) * 360;
                
                ctx.beginPath();
                ctx.arc(x, y1, 3 + amplitude * 3, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${hue1}, 100%, 50%)`;
                ctx.fill();
                
                // ç¬¬äºŒæ¡èºæ—‹
                const y2 = canvas.height / 2 - Math.sin(angle) * (60 + amplitude * 40);
                const hue2 = (hue1 + 180) % 360;
                
                ctx.beginPath();
                ctx.arc(x, y2, 3 + amplitude * 3, 0, Math.PI * 2);
                ctx.fillStyle = `hsl(${hue2}, 100%, 50%)`;
                ctx.fill();
                
                // è¿æ¥çº¿
                if (Math.abs(Math.sin(angle)) < 0.3) {
                    ctx.beginPath();
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y2);
                    ctx.strokeStyle = `hsla(${(hue1 + hue2) / 2}, 100%, 50%, 0.3)`;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
        }

        // æ˜Ÿçˆ†æ¨¡å¼
        function drawStarburst() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const rays = 64;
            
            for (let i = 0; i < rays; i++) {
                const index = Math.floor(i * bufferLength / rays);
                const amplitude = dataArray[index] / 255;
                const angle = (i / rays) * Math.PI * 2 + rotation;
                const length = amplitude * 180 + 20;
                
                const x = centerX + Math.cos(angle) * length;
                const y = centerY + Math.sin(angle) * length;
                
                const gradient = ctx.createLinearGradient(centerX, centerY, x, y);
                const hue = (i / rays) * 360;
                gradient.addColorStop(0, `hsla(${hue}, 100%, 50%, 0.8)`);
                gradient.addColorStop(1, `hsla(${hue + 60}, 100%, 60%, 0)`);
                
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // ç«¯ç‚¹å…‰æ™•
                ctx.beginPath();
                ctx.arc(x, y, 3 + amplitude * 5, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${amplitude})`;
                ctx.fill();
            }
        }

        // é¢‘è°±ç¯æ¨¡å¼
        function drawRings() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const rings = 8;
            const samples = 128;
            
            for (let ring = 0; ring < rings; ring++) {
                const baseRadius = 30 + ring * 35;
                
                ctx.beginPath();
                
                for (let i = 0; i <= samples; i++) {
                    const index = Math.floor((i + ring * 20) * bufferLength / samples) % bufferLength;
                    const amplitude = dataArray[index] / 255;
                    const angle = (i / samples) * Math.PI * 2 + rotation * (ring % 2 === 0 ? 1 : -1);
                    const radius = baseRadius + amplitude * 25;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.closePath();
                
                const hue = (ring / rings) * 360 + (Date.now() / 50) % 360;
                ctx.strokeStyle = `hsla(${hue}, 100%, 50%, 0.7)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        // 3Dæ³¢å½¢æ¨¡å¼
        function drawWaveform3D() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const layers = 10;
            const samples = 100;
            
            for (let layer = 0; layer < layers; layer++) {
                const z = layer / layers;
                const scale = 0.5 + z * 0.5;
                const offsetY = canvas.height * 0.3 + layer * 30;
                
                ctx.beginPath();
                
                for (let i = 0; i < samples; i++) {
                    const index = Math.floor((i + layer * 10) * bufferLength / samples) % bufferLength;
                    const amplitude = dataArray[index] / 255;
                    const x = (i / samples) * canvas.width;
                    const y = offsetY + Math.sin(i * 0.1 + rotation * 5) * amplitude * 50 * scale;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                const hue = (layer / layers) * 360 + (Date.now() / 30) % 360;
                const alpha = 0.3 + z * 0.7;
                ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
                ctx.lineWidth = 2 + z * 2;
                ctx.stroke();
            }
        }

        // æ˜Ÿç³»æ¨¡å¼
        let stars = [];
        function drawGalaxy() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const average = dataArray.reduce((a, b) => a + b) / bufferLength;
            
            // åˆ›å»ºæ–°æ˜Ÿæ˜Ÿ
            if (stars.length < 500 && Math.random() < 0.3) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.random() * 50;
                stars.push({
                    angle: angle,
                    distance: distance,
                    speed: 0.5 + Math.random() * 1.5,
                    size: Math.random() * 2 + 1,
                    hue: Math.random() * 360,
                    life: 1
                });
            }
            
            // æ›´æ–°å’Œç»˜åˆ¶æ˜Ÿæ˜Ÿ
            stars = stars.filter(star => {
                star.distance += star.speed * (1 + average / 100);
                star.angle += 0.01;
                star.life -= 0.003;
                
                if (star.life > 0 && star.distance < 400) {
                    const x = centerX + Math.cos(star.angle) * star.distance;
                    const y = centerY + Math.sin(star.angle) * star.distance;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, star.size, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${star.hue}, 100%, 60%, ${star.life})`;
                    ctx.fill();
                    
                    // æ‹–å°¾æ•ˆæœ
                    const prevX = centerX + Math.cos(star.angle) * (star.distance - star.speed * 3);
                    const prevY = centerY + Math.sin(star.angle) * (star.distance - star.speed * 3);
                    ctx.beginPath();
                    ctx.moveTo(prevX, prevY);
                    ctx.lineTo(x, y);
                    ctx.strokeStyle = `hsla(${star.hue}, 100%, 60%, ${star.life * 0.5})`;
                    ctx.lineWidth = star.size * 0.5;
                    ctx.stroke();
                    
                    return true;
                }
                return false;
            });
            
            // ç»˜åˆ¶ä¸­å¿ƒå…‰æ™•
            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 100);
            gradient.addColorStop(0, `hsla(${(Date.now() / 20) % 360}, 100%, 50%, ${average / 500})`);
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // çƒŸèŠ±æ¨¡å¼ - ä¼˜åŒ–ç‰ˆï¼šæ›´å®¹æ˜“è§¦å‘ï¼Œæ›´å¤šçƒŸèŠ±
        let fireworks = [];
        function drawFireworks() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const average = dataArray.reduce((a, b) => a + b) / bufferLength;
            
            // åˆ›å»ºæ–°çƒŸèŠ± - é™ä½è§¦å‘é˜ˆå€¼ï¼Œé€‚ä¸­çš„è§¦å‘æ¦‚ç‡
            if (average > 20 && Math.random() < 0.1) {
                // æ¯æ¬¡åˆ›å»º2-4ä¸ªçƒŸèŠ±
                const fireworkCount = Math.floor(Math.random() * 3) + 2;
                
                for (let fw = 0; fw < fireworkCount; fw++) {
                    const x = Math.random() * canvas.width;
                    const y = canvas.height * 0.2 + Math.random() * canvas.height * 0.4;
                    const hue = Math.random() * 360;
                    const particleCount = 40 + Math.floor(average / 3); // å¢åŠ ç²’å­æ•°
                    
                    for (let i = 0; i < particleCount; i++) {
                        const angle = (i / particleCount) * Math.PI * 2;
                        const speed = 2 + Math.random() * 5; // å¢åŠ é€Ÿåº¦èŒƒå›´
                        fireworks.push({
                            x: x,
                            y: y,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed,
                            size: 2 + Math.random() * 4, // å¢åŠ ç²’å­å¤§å°
                            hue: hue + Math.random() * 60 - 30,
                            life: 1,
                            gravity: 0.08 // ç¨å¾®é™ä½é‡åŠ›ï¼Œè®©çƒŸèŠ±é£å¾—æ›´é«˜
                        });
                    }
                }
            }
            
            // æ›´æ–°å’Œç»˜åˆ¶çƒŸèŠ±ç²’å­
            fireworks = fireworks.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vy += p.gravity;
                p.life -= 0.01;
                p.size *= 0.98;
                
                if (p.life > 0) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                    gradient.addColorStop(0, `hsla(${p.hue}, 100%, 60%, ${p.life})`);
                    gradient.addColorStop(1, `hsla(${p.hue}, 100%, 50%, 0)`);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    // æ‹–å°¾
                    ctx.beginPath();
                    ctx.moveTo(p.x, p.y);
                    ctx.lineTo(p.x - p.vx * 2, p.y - p.vy * 2);
                    ctx.strokeStyle = `hsla(${p.hue}, 100%, 60%, ${p.life * 0.5})`;
                    ctx.lineWidth = p.size * 0.5;
                    ctx.stroke();
                    
                    return true;
                }
                return false;
            });
        }

        // çŸ©é˜µæ¨¡å¼
        let matrixColumns = [];
        function drawMatrix() {
            if (matrixColumns.length === 0) {
                const columnCount = Math.floor(canvas.width / 20);
                for (let i = 0; i < columnCount; i++) {
                    matrixColumns.push({
                        x: i * 20,
                        y: Math.random() * canvas.height,
                        speed: 2 + Math.random() * 5,
                        chars: []
                    });
                }
            }
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.font = '16px monospace';
            
            matrixColumns.forEach((col, index) => {
                const dataIndex = Math.floor(index * bufferLength / matrixColumns.length);
                const amplitude = dataArray[dataIndex] / 255;
                
                col.y += col.speed * (0.5 + amplitude);
                
                if (col.y > canvas.height) {
                    col.y = -20;
                    col.chars = [];
                }
                
                // æ·»åŠ æ–°å­—ç¬¦
                if (Math.random() < 0.3) {
                    col.chars.push({
                        char: String.fromCharCode(0x30A0 + Math.random() * 96),
                        y: col.y,
                        brightness: 1
                    });
                }
                
                // ç»˜åˆ¶å­—ç¬¦
                col.chars = col.chars.filter(char => {
                    char.brightness -= 0.02;
                    
                    if (char.brightness > 0) {
                        const hue = 120 + amplitude * 60;
                        ctx.fillStyle = `hsla(${hue}, 100%, ${50 + amplitude * 30}%, ${char.brightness})`;
                        ctx.fillText(char.char, col.x, char.y);
                        return true;
                    }
                    return false;
                });
            });
        }

        // äº‹ä»¶ç›‘å¬
        startBtn.addEventListener('click', () => {
            if (!isActive) {
                initAudio();
            } else {
                stopAudio();
            }
        });

        modeBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                modeBtns.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                visualMode = btn.dataset.mode;
                particles = [];
            });
        });

    </script>
</body>
</html>
